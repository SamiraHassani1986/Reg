#!/usr/bin/env python3

"""
..Author: Stefano Piani, stefano.piani@exact-lab.it
..Date: 2017-10-23

This script stops the execution of cordex_listener.py

It uses the pid file generated by cordex_listener to individuate its PID, and
then it sends a USR1 signal. This triggers a greaceful stop for
cordex_listener: it will elaborate all the files that are present when it
receives the signal and then exit.
If a timeout is reached, this script sends a TERM signal to trigger a fast stop
for cordex_listener: it will stops as soon as it closes the file it is working
on at that moment.
Optionally, another timeout can be set to send a KILL signal for terminating
cordex_listener immediately

The execution of this script ends when cordex_listener is not running anymore
"""

import os
import argparse
from traceback import format_exc
from sys import argv, exit as sys_exit
from time import sleep
import signal
import logging

from utilities.log_utilities import OnelinerFormatter


__copyright__ = 'Copyright (C) 2017-2018 ICTP'
__author__ = 'Stefano Piani <stefano.piani@exact-lab.it>'
__credits__ = ["Stefano Piani"]


# The time after witch a sigterm is send
SIGTERM_TIMEOUT = 600

# The time step for checking if cordex_listener is still running
TIMESTEP = 1

LOGGER = logging.getLogger()


def _create_input_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '-p',
        '--pidfile',
        help='The path of the PID file generated by cordex_listener.py',
        type=str,
        required=True
    )

    parser.add_argument(
        '-f',
        '--fast',
        help='Send signal USR2 instead of USR1 to stop the cordex_listener. '
             'Therefore, the listener will use the maximum number of cpus '
             'until its execution ends.',
        action="store_true",
        default=False
    )

    parser.add_argument(
        '-t',
        '--timeout',
        help='The amount of time after which a SIGTERM is send to the '
             'cordex_listener to force a faster termination of the execution '
             '(in seconds). Default is {} seconds'.format(SIGTERM_TIMEOUT),
        type=int,
        default=SIGTERM_TIMEOUT,
    )

    parser.add_argument(
        '-k',
        '--kill',
        help='The amount of time after which a SIGKILL is send to the '
             'cordex_listener to force it to exit immediately (in seconds, '
             'since when the SIGTERM has been sent). By default, this signal '
             'is never submitted',
        type=int,
        default=None
    )

    parser.add_argument(
        '-v',
        '--verbosity',
        choices=['debug', 'info', 'warning'],
        default='info',
        help='The level of verbosity of this script'
    )

    parser.add_argument(
        '-s',
        '--silent',
        help='Do not print logs on current terminal',
        action="store_true",
        default=False
    )

    parser.add_argument(
        '-l',
        '--logfile',
        help='The path of the log file of this script',
        type=str,
        default=None
    )

    return parser


def is_running(pid):
    """ Check if a process with a specified pid is running """
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    else:
        return True


def _prepare_logger(verbosity, silent_mode, log_file):
    verbosity_level = getattr(logging, verbosity.upper())
    LOGGER.setLevel(verbosity_level)

    if not silent_mode:
        streamformatter = logging.Formatter('%(levelname)s: %(message)s')
        streamhandler = logging.StreamHandler()
        streamhandler.setLevel(verbosity_level)
        streamhandler.setFormatter(streamformatter)
        LOGGER.addHandler(streamhandler)

    if log_file is not None:
        fileformatter = OnelinerFormatter(
            '%(asctime)s - %(levelname)s - %(funcName)s: %(message)s',
            datefmt='%Y/%m/%d %H:%M:%S'
        )
        filehandler = logging.FileHandler(log_file)
        filehandler.setLevel(verbosity_level)
        filehandler.setFormatter(fileformatter)
        LOGGER.addHandler(filehandler)

    # This avoid problems if no other handler is applied on the LOGGER
    LOGGER.addHandler(logging.NullHandler())


def main():
    # Read the options from command line
    parser = _create_input_parser()

    # If no arguments are submitted, print help
    if len(argv) <= 1:
        parser.print_help()
        return 1

    args = parser.parse_args()

    # Prepare logger
    _prepare_logger(args.verbosity, args.silent, args.logfile)

    LOGGER.debug('Opening file %s', args.pidfile)

    attempt = 0
    pid_raw = None

    # Try to read the file. If the file is not there, maybe the daemon is not
    # ready. Try again for 5 seconds
    while pid_raw is None:
        try:
            with open(args.pidfile, 'r') as f:
                pid_raw = f.read().strip('\n')
        except Exception:
            attempt += 1
            if attempt > 5:
                raise
            sleep(1)

    LOGGER.debug('The PID read from file is: {}'.format(pid_raw))

    pid = int(pid_raw)
    cordex_listener_runs = True

    LOGGER.info('Stopping cordex_listener execution...')
    if args.fast:
        LOGGER.debug('Sending signal USR2 to pycordex_listener')
        os.kill(pid, signal.SIGUSR2)
    else:
        LOGGER.debug('Sending signal USR1 to pycordex_listener')
        os.kill(pid, signal.SIGUSR1)

    elapsed_time = 0

    # This will run indefinitely if args.timeout is > 0, otherwise
    # this code will be skipped
    while args.timeout > 0:
        if not is_running(pid):
            LOGGER.info('cordex_listener is not running anymore')
            cordex_listener_runs = False
            break

        if elapsed_time > args.timeout:
            LOGGER.info('Timeout reached! TERM signal will be send')
            os.kill(pid, signal.SIGTERM)
            break

        sleep(TIMESTEP)
        elapsed_time += TIMESTEP
        LOGGER.debug('Checking if cordex_listener is still running...')

    if not cordex_listener_runs:
        return 0

    if args.kill is not None:
        elapsed_time = 0
        while True:
            if not is_running(pid):
                LOGGER.info('cordex_listener is not running anymore')
                cordex_listener_runs = False
                break

            if elapsed_time > args.kill:
                LOGGER.info('Timeout reached! KILL signal will be send')
                os.kill(pid, signal.SIGKILL)
                break

            sleep(TIMESTEP)
            elapsed_time += TIMESTEP
            LOGGER.debug('Checking if cordex_listener is still running...')

    if not cordex_listener_runs:
        return 0

    while is_running(pid):
        sleep(TIMESTEP)
        LOGGER.debug('Checking if cordex_listener is still running...')

    return 0


if __name__ == '__main__':
    try:
        exit_code = main()
    except SystemExit:
        exit_code = 1
    except Exception:
        LOGGER.error(format_exc())
        exit_code = 2

    if exit_code == 0:
        LOGGER.info('Execution completed')

    sys_exit(exit_code)
